# homero_valeria_bimal_jorge_md_run
Potential source: http://pseudopotentials.quantum-espresso.org/upf_files/Ta.pbe-spfn-kjpaw_psl.1.0.0.UPF

0. Make 2 dir: normal_modes (with subdir.: stage_1, ....., stage_4) & force_constants with subdir.: stage_0, ....., stage_3
               >>> force_constants >> stage_0 files: "fc_Ta_3.306_300K_QE_in_stage_0" from HELD 1000K run
                                   >> stage_1 to stage_3 files: empty
               >>> normal_modes >> stage_1 files: band.conf, Ta.in, POSCAR, QPOINTS (from step 1), SPOSCAR (from step 2.3), header.in 
                                >> stage_2 to stage_4 files: empty

1.'normal_mode_locator.py' >>>> Generate QPOINTS (64 qpoints default)

For this part, first run 'normal_mode_locator.py' which will create a file called QPOINTS which tells phonopy to solve the dynamical matrix at particular qpoints. The qpoints generated by 'normal_mode_locator.py' are the commensurate qpoints: qpoints whose waves are confined in the supercell used in the phonon calculation. The commensurate qpoints are the normal modes of the system, the number of normal modes is three times the number of atoms in the supercell (one for each degree of freedom). This number is equal to the number of unit cells in the supercell times the number of phonon branches. For example, a system with 2 types of atoms has 6 branches. If the supercell is 4x4x4, thus containing 64 unit cells, the number of normal modes is 64 * 6 = 384. This is equal to the number of atoms 2*4x4x4 = 128 times the number of degrees of freedom, 128 * 3 = 384.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2. The next part consists of computing the Eigen-frequencies and Eigen-vectors of the dynamical matrix at the normal mode qpoints using phonopy. Phonopy needs the following files: QPOINTS, POSCAR, SPOSCAR, FORCE_CONSTANTS.
    2.1 QPOINTS was created in the previous step
    2.2 POSCAR must be provided by the user and includes the basis vectors of the primitive lattice (the unit    cell) and the number, type, and 
        positions of the atoms (the motif).
    2.3 SPOSCAR can be created from POSCAR using phonopy in 'anaconda prompt (anaconda3)', for example using the the command:
        { phonopy -d --dim="4 4 4" } 
       in the command line produces a 4x4x4 supercell with 128 atoms in SPOSCAR.

###################################################
2.4 FORCE_CONSTANTS can be generated with HELD :   (use "froce_constants" directory)
    2.4.1 From either a guess or use FC from another qlat+temp. HELD run (if this is stage_0);
    2.4.2 From Previous run (otherwise), if so, run '.../normal_modes/frequency_calculator.py.' 
          This code needs SPOSCAR to be in the directory and needs the values of the force constants. The easiest way to do this is to grab a the 
          values in a row from one of the force_constant CSV files produced by HELD, since then the order of the force constants is consistent. 
          Nevertheless, the values can be provided manually as well.

##################################################
2.5 'frequency_calculator.py' uses phonopy to calculate the frequencies, and phonopy needs a configuration file (band.conf, for example) that includes at least the following flags (the value for DIM can change but not the others). Make sure that the configuration file is in the directory. Phonopy will write a file named 'phonopy.yalm' with the results that will be used in the next part. 

DIM = 4 4 4
READ_FORCE_CONSTANTS = .TRUE.
QPOINTS = .TRUE. 
FULL_FORCE_CONSTANTS = .TRUE.
EIGENVECTORS = .TRUE.
WRITEDM = .TRUE.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3. The next step consists of generating atomic positions that are consistent with the normal modes at a given temperature.
3.1 Run:      
     '/normal_modes/stochastic_position_generator.py'
This will generate 20 instances file that contains "positions", "KPOINTS" and "cell parameter (a)"
with file name "Ta_3.304_300K_QE_in_stage_1_instance_....*"

The temperature 'temp' and number of configurations 'nconfigurations' must be provided by the user in the code, as well as some weird things like the mass of the types of atoms in the system. The code needs the information in SPOSCAR and in 'phonopy.yalm' generated in previous steps and it writes atomic configurations in the QE format.
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
4. Do short MD runs using the generated atomic configurations and use HELD to get updated (more accurate) force_constants.  
4.1 Copy 'increate' and  2 'jobcreate..py' file to each stage in normal_modes and Run "increate" to generate .in file for MD run
     anaconda prompt terminal cmd: bash increate
     use python for: 'jobcreate.py' & 'jobcreate_embeded.py'
     
NOTE: double check temp, lattice, natoms and all possible parameters
NOTE: jobcreate.py create all 20 job "pjob-{i}" script for each .in file
NOTE: jobcreate_embeded.py create single file "pjob_all.sh" to run all 20 .in file at once.

4.2 Run thus created .in file in supercomputer using "job-$i" files.
4.3 Download ".out" file to the local computer in the same stage of the "normal_modes" directory.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
5. Repeat steps 2 (2.4.2) - 4 (4.3) until convergence in the values of the force constants is reached.
